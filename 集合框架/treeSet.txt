实现  红黑树算法        自然排序  (从小到大 )

必须是同一个数据类型  不然 无法排序


实现 java.uilt.Comparable(可比较的)

用compareTo方法 比较  来保证是同一个对象   (自然排序) 


compare方法是定制排序



注意，此实现不是同步的。
SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...));




排序 是  树一样的  大的 在右(返回的1)                      小的在左  (返回的是-1)                     相等 (返回0 表示不存)
    
Comparator  优于 Comparable    


自然排序 ,

       要求在TreeSet集合中的对象必须实现java.lang.Comparable接口  并覆盖compareTo方法

	比较名字  或者叫 String类型的数据 可以调用String类的comparable



定制排序    (记住)

      要求在构建  TreeSet对象的时候     传入一个比较器对象  必须实现java.lang.Comparator接口
在比较器中覆盖compare方法 并编写比较规则

public TreeSet(Comparator<? super E> comparator)
构造一个新的，空的树集，根据指定的比较器进行排序。
 
参数 
comparator - 将用于对该集合进行排序的比较器。 如果null ，该natural ordering的元素将被使用。

 类于  class   类名  implements   Comparator <填写比较对象类型>{
	复写
	       public int  compare(  类型  o1,   类型   o2   ){
		if(                  )      //比较规则
		     类似	o1 > o2  retuen  1  
		else if (    )   
                                       类似	o1 > o2  retuen  -1
		else 
		       0
	}
}


创建对象的时候    Set<>      set  = new       TreeSet<>( new     类名()  );   


	Tree类型的都有这个功能





