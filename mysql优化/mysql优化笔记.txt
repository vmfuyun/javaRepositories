商业需求对性能的影响:
	主页问题:查询游记总数 不要使用count(1) 因为会进行全表搜索,
	表很大后;(表的数据达到一定的数量的话,就不能用显示全部 也不能查所有的) 分页操作 第一步就不要去mysql查看总条数了(把总条数存redis,查也去redis),第二步,还是通过搜索进行limit 显示
	无用的功能堆积,
系统架构对性能的影响:
	不适合放在数据库中的存放的数据>>二进制多媒体数据,流水队列(日志),超大文本
	是否合理的利用应用层的Cache机制>>系统参数,活跃用户的基本信息,准实时的,一般更改少的访问比较频繁 的
	冷热数据的分离

mysql的系统架构
	主要有:mysql server  -->sql Layer  -->storagr Engine Layer
	
	把mysql的执行流程,弄一遍

sql的优化
	innodb的存储  使用的.frm存储表结构,使用的.idb存储数据结构,  支持事务
	myIsam存储使用的三个文件,.frm表结构,使用的.myd数据存储,   .myi存储索引
	
	索引:索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。
		MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。
	索引的分类:
		B+Tree 索引,哈希索引
	
红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：
（一）更少的查找次数
平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。
红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。

（二）利用磁盘预读特性
为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。
操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。

	
	哈希索引
哈希索引能以 O(1) 时间进行查找，但是失去了有序性：
无法用于排序与分组；
只支持精确查找，无法用于部分查找和范围查找。
InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

innodb和myIsam是无法选择索引是什么的 一般只支持 B+tree 


	MyISAM 实现索引 myd   myi  
		自己建立的是索引(二级)   存的都是对应的物理地址,会有可能会有重复的 数据有可能是重复的
	Innodb  
		因为数据和索引是一个文件所以是 直接挂上 数据的	
		二级索引,存的数据是 唯一索引的key的id 所以,查询的话需要查询两次,,,为什么不去存 数据的物理地址呢,  因为是innodb是存比较多,为了不去修改二级索引
	聚簇索引:
		数据和索引在一起的是聚簇索引, 例如innodb'
		不再一起的是非聚簇索引, 例如 myISAM

索引的利弊:
	树的维护
	索引优势:
	大大减少了服务器需要扫描的数据行数。
	帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。
	将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。
	


	什么样的建立索引;
	较频繁的查询,并很少修改的就建立索引,
	唯一性很差的就不建立了  就是重复的数据比较多的 就不要建立
	不会出现在where 之后的就不要建立索引了

	select * from table where 条件a and 条件b  and 条件c     单列索引
	这种只能用到 一个树  因为 出来的是临时表  是无法使用 一个临时表的树
	
	组合索引: 多列索引
	把多个条件建立一个索引,
	在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好
Explain命令	
	selectType          dependent subquery     union     派生表  derived  
	type               system const 表示是一个性能最好的    
		     eq_ref  主键关联的查询 是快的 
		     ref  非唯一主键 或者索引 查询
		    ref_or_null  树不会有null  所以专门有一个表处理null   --->一般是不能有null 可以设置成默认值
 			主键索引是 连接索引  
		or的语句时候 可以使用的是两个索引
		index  扫描的是 索引
		all  扫描的是全文

	


	key_len的长度计算公式：
varchr(10)变长字段且允许NULL    =  10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL)+2(变长字段)
varchr(10)变长字段且不允许NULL =  10 *( character set：utf8=3,gbk=2,latin1=1)+2(变长字段)

char(10)固定字段且允许NULL        =  10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL)
char(10)固定字段且不允许NULL        =  10 * ( character set：utf8=3,gbk=2,latin1=1)
	

索引使用的策略和 优化: 
	1,全列索引匹配;   就是组合索引 是不在意位置,只要三个都在的时候  就会全部索引搜索.  但是 中间断一个 会变成一个索引匹配的	  
	     索引覆盖: 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量, 也就是只访问索引.
	     注意:函数表达式 是不能用索引的...
	
	2,索引的最左原则:,,,   就是说 联合索引 左边的添加满足 才能用上索引  不然就用不上
	    为了满足 最左原则  为了实现 全部应用索引  补坑 把中间的补上 使用in

	3,like 的前缀开头的模糊查询是 可以应用索引,   模糊在前面是用不到的  比如:   like  "%xxx" 这样是用不了索引
	
	4,范围查询 只会 用范围查询的 进行索引,但是 between     and   是可以应用上所有的索引

建立索引的原则:
	索引的选择性, 不同值比上总数的 比值  一般越接近  1 越好
	  前缀索引    索引太大的话 使用 截取前缀来实现  一般会使用到 left 5  截取5
	Innodb 尽量主键自增 ,因为b+tree 数据结构的原因,正好在右边添加 连续性;

join原理 		 匹配原理  如果内表没有索引的话,循环进行匹配       simple Nested-Loop join
			内表的匹配的是索引的话  匹配索引        Index nested-Loop join
			使用join buffer 在内存中 进行批量匹配 减少了对内表的匹配  Block Nested-Loop Join
		性能对比:   Index>Block>simple
	
join优化原则:
	1,小表(数据行数小)驱动大表       减少外层的循环次数     left join是指定的          straight  join   强制指定 左边驱动右边
	只要索引的话  会比较快 
	2,增加 join buffer的空间  在mysql.ini 增加到8m       不要用select *  主要为了 减少存在join buffer中无用的 字段的数据
	
优化 orderBy 双路排序;   单路
	单路和双路的区别?
	1）双路排序会读取两次表， 且第二次是随机读取的
	2）单路排序的元组比双路排序要长，导致它需要多次向临时文件写入内容，增加IO操作，当需要返回的列的总长度很长时尤其明显。
	MySQL根据max_length_for_sort_data变量来确定使用哪种算法，默认值是1024字节，如果需要返回的列的总长度大于max_length_for_sort_data，使用第一种算法，否则使用第二种算法。
	这个大小 是通过读取表文件来实现的
	
		增大Sort Buffer 
		去掉没用的字段,
		加大那个限制值
		使用orderBy   + limit
	尽量不要有临时表(usingtemporary),   有排序一类的操作  尽量是在一个表  一般是小表
	using temporary 是多表进行join 然后进行拍寻的时候 会使用这个

	filesort  使用的是排序 放到一个临时文件上

	两个表 join操作 加排序---->一般排序的字段是驱动表的话,  会更更快, 这样就避免了临时表(这种情况正好排序的字段,两个表都有)

sql优化原则:	
	一般使用统表   能使用到索引 比较快  
	  如果 使用排序的话  要在驱动表来实现,                       排序  排序字段 尽量是 驱动表的    ,
	,,  因为如果是驱动表的话     排序字段 尽量是 驱动表的   会先进行排序,再去连接  不会用到临时表    这样速度更快-

	尽量不要用临时表,用派生表  也就是 子查询的表 , 一般把派生表进行连接查询, where 后面不能有子查询,把子查询变成一个 查询的表 ,也叫做派生表










