Classloader-->1,热部署,代码加密
	        2,可以保证这个类在这个java虚拟机的唯一性
分类:
	虚拟机自己的类加载器:  启动类加载器 Bootstrap Classloader
		拓展类加载器:Extension ClassLoader    在java\lib\ext
		应用程序类加载器 Application ClassLoader  加载的是Classpath
	启动类加载器
	         |
	扩展类加载器
	         |
	应用程序类加载器
	|	        |
        自定义类加载器    自定义类加载器
	自定义的类加载器 需要继承java.lang.ClassLoader

双亲委派:
	使用的是组合关系来实现 类的唯一被加载:   先去顶层 (父加载器) 然后再去子类
	破坏双亲委派机制:  1,复写 ClassLoader类的 loadClass方法   
		              2,在线程的上下文获取对应的上下文类加载器对象   Thread.currentThread().getContextClassloader()
java 运行在虚拟机上:
	人为数据分区:
	方法区,堆---->线程公用:
	虚拟机栈,本地方法栈,程序计数器--->线程隔离
为对象分配地址:
	内存是归正,使用是 指针碰撞 也就是移
	内存不是归正的,TLAB(空间列表)                                       如何选择呢?一般要看垃圾回收机制是不是有压缩整理的算法 如果有,就使用指针
回收什么?
	判断对象是否存活?
	引用计数算法,-->用的时候 +1,没有用-1  弊端是相互引用
	可达性算法-->也就是能不能找到 能找到就是活的,
	
	GC Roots 的对象:
	1,虚拟机栈  (栈帧中的本地变量表) 中的引用对象
	2,方法区中静态属性引用的对象
	3,方法区中常量引用的对象
	4,本地方法栈中JNI 也就是Native方法引用的对象     可达性很耗时
怎么保证更好的操作(效率)?  
	java会把所有的线程停止  stop the world    
	解决方案:
	1,枚举根节点, OopMap  在类加载完成的时候,会把对应的引用记录到对应的Map中,每次就只要去,查询这个map 就可以了
	2,使用的是 一个安全点 比如说执行到100行的时候 需要停下  进行 垃圾回收,
	3,为了有可能的线程是 挂起的 比如说:休眠,  运行不到 安全点  怎么办?  使用安全区,也就是  在这个区域的话 就会执行 垃圾回收!!!
	
	引用:
	强引用:  使用new进行赋值的,
	软引用:  类实现软引用
	弱引用:   
	虚引用:
 方法区的回收:
	永久代  常量的回收,  没有对象,类加载器也是垃圾后,类就可以被回收,     
		被启动类加载器,扩展类加载器,应用程序类加载器,加载的类是不会被卸载的
垃圾回收算法:
	1,标记.清除    --->就是标记  清除  位置不会改变的  一般不会再用了,因为需要停整个应用.
	2,标记,整理    --->  标记   删除 然后把 位置进行整理   --用于老年代
	3,复制	     --->删除后 直接复制到另一半   --一般用于存活的对象比较少的地方-->新生代
	4,分代收集     --->     伊甸区 Eden Space     幸存  Survivor
分代:
	新生代:  生存比较短的对象.    一般会生成一个伊甸 两个老年区  一个是from   一个是To  
		一般伊甸(8M)满了一次Gc会把活对象放到from,   然后 就是把from也放在To 然后交换内存  这样就不会有碎片,
		下次就直接 去扫描form和伊甸
	老年代:   GC操作很费时间,所以要一次GC就很明显
GC收集器:
	7个   Serial/Serial old  串行的    单线程, 会把其他的线程停掉
	         ParNew收集器    GC的并行版本
	         Parallel/Parallel Old收集器    按着GC的使用量来实现的 也就是说吞吐量        这五个都会把工作线程停止
	         CMS  收集器    最短的回收停顿  是把线程 停的时间 变的很短 
	         G1   有一个可以预测停顿时间
大对象去老年代: 
	条件是大于伊甸区的一半 4M
动态年龄判断:
	
	
.