动态代理
	
	作用:它能把把原先的 类的方法 增加  功能 --------    需要增加额外的功能的话  就用动态代理

	在程序在 程序运行期间 由 jvm通过 反射---来生成代理---只有在运行的时候 才确定的真实对象和代理对象
	是在jvm 生成一个字节码
	是不会看到真实类的
-----动态代理对象是怎么创建?
	怎么增强的
	
如何实现
	有接口--jdk动态代理
	没有接口的--cglib

proxy--newproxyinstance()----classlord
			interface
			要做什么增强

	han---invoke

	method.invoke是真实类的操作



jdk 原理
	直接通过反射得到 每一个 method  然后调用 而已
	它直接实现了 接口  就是得到所有的方法
	底层是大概是把方法 列出来  然后调用的时候  就调用对应的方法  会调用对应的invoke方法(proxy,method,Object[] args)

tostring
hashCode
equals 
是jdk动态代理实现的方法  也就是能进行增强
	

cglib---继承方式 (模板方法)---不用接口  --spring已经集成了
	创建代理对象不一样
	enhancer ----spring-cglib包
	这是一个子类  
	setsuperclass----设置父类
	setCallback() 设置控制器  	回调--
	enhancer--cre---创建

	增强和原先一样  invoke  

总结 
	jdk是必须有接口  -----是由proxy类 和 invocationhandler接口---一个是代理 一个是增强
	cglib是继承  所以 继承是有局限的 不能继承priavte - 所以用动态代理的话 就用public
	最小单位是类
选用  能用jdk就jdk(接口)-------- cglib的话 就要求非fina--非static 非private

	shiro--是基于cglib
aop 面向切面编程的思想
	横切面关注点  ---重复的模块
	一个模块是一个个

	切面 就是 一圈一圈的 如果 想到中间 需要经过 好几个圈  这些去哪就是切面代码

where  在------位置--方法-类 包 - 
when  时机---
what----做什么增强


execution   方法签名  从后到前看  (增强到方法)    ..是子包的意思----  这个表达式要确定到方法 解决了 动态代理的确定类的 弊端
	(..)前必定是方法名  
	* 开头就是修饰符  其余的都是一个 通配符的意思

	execution(* cn.woIfcode.proxy.*ServiceProxy.*(..))
	

直接到方法 去复制 
	Aspect:切面,----pointcut(切入点,where的意思 用到了execution表达式(精确到方法用于 要给谁 加强  )   有一个名字id--供后面的when用   ) + Advice(增强的 代码类-- )
	Aspect标签里 有 ref  也就是 what  就是增强了什么

		<aop:before method="begin" pointcut-ref="serviceTX"/>--    这就是when  什么时候  注意后面是一个对应的输出--
	注意execution 表达式 是确定那个方法的 一 一对应的 如果不对应 会没有效果






动态代理
	注意 继承方式的话  导入的是cglib   注意测试类才写 标签