//方法覆盖

/*
场景:
	子类拓展了父类，可以获得父类的部分方法和成员变量。

	可是当父类的某个方法不适合于子类本身的特征时，此时怎么办？
		如:企鹅(Penguin)和鸵鸟(Ostrich)是鸟类中的一个特殊品种，
		所以企鹅/鸵鸟类是鸟类的一个子类，但是鸟类有飞翔的功能，
		但是对应企鹅/鸵鸟，飞翔的行为显然不适合于它。

此时肿么办?

*/

/*
方法覆写的原则（一同两小一大）：Override

一同：
1)	实例方法签名必须相同。 
		(方法签名= 方法名 + 方法的参数列表)

两小：
2)	子类方法的返回值类型是和父类方法的返回类型相同或者是其子类。
		子类可以返回一个更加具体的类.
3)	子类方法声明抛出的异常类型和父类方法声明抛出的异常类型相同或者是其子类。9
	子类方法中声明抛出的异常小于或等于父类方法声明抛出异常类型；
	子类方法可以同时声明抛出多个属于父类方法声明抛出异常类的子类(RuntimeException类型除外)；

一大：
4)　子类方法的访问权限比父类方法访问权 限更大或相等。
		public > protectde > 无 > private
	private修饰的方法不能被子类所继承,也就不存在覆盖的概念.

判断是否是覆写方法的必杀技：
	@Override标签：若方法是覆写方法，
	在方法前或上贴上该标签， 编译通过，否则，编译出错。

只有方法存在覆盖的概念,字段没有覆盖.

方法覆盖解决的问题:  
	当父类的某一个行为不符合子类具体的特征的时候,
	此时子类需要重新定义父类的方法,并重写方法体.

*/

//鸟类
class Bird
{
	public void fly()
	{
		System.out.println("我飞我飞我飞飞飞~");
	}
}

//企鹅
class Penguin extends Bird
{
	//重新定义fly方法
	@Override//用于判断当前子类方法是否覆盖了父类方法
	public void fly()
	{
		System.out.println("等我减肥了就能飞了~");
	}
}

class  OverrideDemo
{
	public static void main(String[] args) 
	{
		//创建一个企鹅对象,不会飞的鸟
		Penguin p = new Penguin();
		//就近原则,先找子类,再找父类,依次向上找,再没有则编译报错
		p.fly();
	}
}