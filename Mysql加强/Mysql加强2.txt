子查询
	子查询指的就是在一个查询之中嵌套了其他的若干查询
	在where查询条件中的限制条件不是一个确定的值，而是一个来自于另一个查询的结果。
	一般出现在 from 和where 
	   (原因是 from 和where 后面是不能添加      函数) 所以只能 通过一个子查询来实现
	在mybatis中一般是单条查询 然后 传入
书写注意点:
	1,要用括号 括起来 当一个整体
	2,将子查询放在比较运算符的右边(增强可读性)
	3,单行子查询用 单行 ,多行 就用多个子查询条件

子查询的分类:
	1, 单行,单列,值  where  应用比较运算符
	2,多行,多列,集合 where 	in   相当于 =any(子查询语句)----重
		>all(子查询语句) 大于这个范围中的 最大的            <all(子查询语句)  小于最小的	(也就是说后面的多行是一个数据)
		
		>any 大于 这个范围中最小的 		<any 大于 这个范围中最大的
		
		-- <>ANY 与NOT IN 
		--<>ANY
		--OR作用 父查询中的结果集不等于子查询中的a或者b或者c,则为真----		说明 只要有一个不相等  就不相等
		SELECT * FROM T2 WHERE N <>ANY(SELECT * FROM T1)



	3,多列多行,表    (必须要给子查询起一个别名)       		 from   
DML操作
插入操作  insert
	sql语句是有长度限制的  在my.ini 的max_allowed_packet参数改
更新操作
	update  set         where       如果是两种表的   可以把连接条件 在where    注意 子查询的使用
删除操作
	

数据库中事务的控制
	数据库的事务,所谓事务是指多个操作,使数据从一个状态到另一个状态,我们把这种不能分割的多个操作 叫做事务
	
	事务是怎么保证 一致性(未提交前,是不能被别的查看的);永久性(会被永久的保存起来); 原子性(要么都成功,要么都失败),
	通过事务的操作语句   begin 事务开始   ;
			commit 事务提交;
			rollback 回滚;
	
开发中,我么可以不使用外键,但是必须使用事务 所以要用innoDB,

数据库的并发问题
	操作同一个资源
	1,回滚丢失--注意是一个 操作导致的
	2,覆盖丢失
	3,幻读--a事务把b事务的结果 读取了     --一般用锁机制就能避免
	4,脏读---a事务把b事务中没有提交的数据 读取了  --Oracle是不会出现脏读
	5,不可重复读--- a事务读取了b提交的更改的数据
隔离级别
	不同的隔离级别可能会导致不同的数据库并发问题,隔离级别越高,性能越低.
	
	主要有 
	1.READ UNCIMMITTED（未提交读）事务中的修改，即使没有提交，其他事务也可以看得到，
							比如说一种现象就叫做脏读
	2.READ COMMITTED（提交读）
　	　大多数数据库系统的默认隔离级别是READ COMMITTED，这种隔离级别就是一个事务的开始，
	只能看到已经完成的事务的结果，正在执行的，是无法被其他事务看到的。这种级别会出现读取旧数据的现象
	
	3.REPEATABLE READ（可重复读）
 　	　REPEATABLE READ解决了脏读的问题，该级别保证了每行的记录的结果是一致的，
	也就是上面说的读了旧数据的问题，但是却无法解决另一个问题，幻行，顾名思义就是突然蹦出来的行数据。
	指的就是某个事务在读取某个范围的数据，但是另一个事务又向这个范围的数据去插入数据，导致多次读取的时候，数据的行数不一致。
	
	4..SERIALIZABLE（可串行化）
	SERIALIZABLE是最高的隔离级别，它通过强制事务串行执行（注意是串行），
	避免了前面的幻读情况，由于他大量加上锁，导致大量的请求超时，因此性能会比较底下，
	再特别需要数据一致性且并发量不需要那么大的时候才可能考虑这个隔离级别
	
	sql92 的隔离级别 repreatable  read  (可重复读)-以保证数据的读 一致性    
	 用可以通过根据具体的需求来选择隔离级别     mysql中锁基于索引机制, 
	
	丢失更新问题,解决方案
锁
	悲观锁
	写锁-----DML会直接自动加锁   
		ddl 可以 手动加锁  -- 语句是 for update  
	类似于 在表中加一个列 (版本号) 来区别 操作的事务   ,每次操作 进行+1
	事务a在操作的时候 会有其余的事务来干扰
	
	查看是否隔离级别
	SELECT @@tx_isolation;
	MySQL默认是可重复读

	
	

	乐观锁
	事务a,在操作的时候 乐观的认为没有其他的事务 没有来干扰

	步骤: 
	1,表中加一个列,varsion,来区别
	2, 每次修改数据的时候 要把varsion 查询出来  
	3,然后再使用, varsion加1 进行操作
	4,如果执行语句 返回的影响行是 >0, 提交事务 否则 回滚  rollback;  
	
	



表锁
	MyISAM 支持表锁，InnoDB 支持行锁    
	--锁基于索引机制


权限  
	约束用户 , 限制用户是否有那些权力      为了系统的安全.
	
	
	全局权限 在 db  ,  存放在mysql-user表中   
	(用户权限) 全局权限 是服务器权限-----属于 全服务器的   大于 数据库权限  ---编辑用户(建立用户的时候 要添加的权限)
		
	数据库权限     权限管理员---添加权限	



	局部权限 (表),tables	----
  熟悉 怎么操作























/* 子查询 */ ------------------
    - 子查询需用括号包裹。
-- from型
    from后要求是一个表，必须给子查询结果取个别名。
    - 简化每个查询内的条件。
    - from型需将结果生成一个临时表格，可用以原表的锁定的释放。
    - 子查询返回一个表，表型子查询。
    select * from (select * from tb where id>0) as subfrom where id>1;
-- where型
    - 子查询返回一个值，标量子查询。
    - 不需要给子查询取别名。
    - where子查询内的表，不能直接用以更新。
    select * from tb where money = (select max(money) from tb);
    -- 列子查询
        如果子查询结果返回的是一列。
        使用 in 或 not in 完成查询
        exists 和 not exists 条件
            如果子查询返回数据，则返回1或0。常用于判断条件。
            select column1 from t1 where exists (select * from t2);
    -- 行子查询
        查询条件是一个行。
        select * from t1 where (id, gender) in (select id, gender from t2);
        行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...)
        行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。
    -- 特殊运算符
    != all()    相当于 not in
    = some()    相当于 in。any 是 some 的别名
    != some()   不等同于 not in，不等于其中某一个。
    all, some 可以配合其他运算符一起使用。