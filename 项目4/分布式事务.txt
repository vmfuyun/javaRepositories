 因为 多个服务   多个数据库  一个操作分成了多个
	

分布式事务:指事务的操作位于不同的节点上，需要保证事务的 ACID 特性。
例如在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务。


  怎么处理分布式事务的问题?
	1.在设计的时候-->能避免就避免
	2.如果在设计的角度,无法避免  肯定要去解决;
		1>考察业务出错的几率,如果出错频率小,影响范围小, 就不去处理, 出现了就人工处理
		2>频率高,影响范围大 ,那就必须做了
常见的处理方法:
	1,基于MQ可靠消息实现数据最终一致性(对实时要求比较低的)
	2,使用开源框架:
		TCC-transaction
		Byte-TCC
		LCN
		GTS        .....
TX,XA 事务管理器方案:
	局限性: 存储数据的数据库 需要实现的协议XA,   需要等待整个事务完毕 (效率低), 故障率问题
CAP定理:
	分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。
	一定要满足P  所以一般看是cp还是ap.
BASE 
	是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。
BASE 理论
	是对 CAP 中一致性和可用性权衡的结果，它的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，
	采用适当的方式来使系统达到最终一致性。
可靠消息的最终一致性方案:
	消息发送一致性:  要消费者实现幂等性操作,要生产者必须把消息发送过去(把消息持久化),
		使用消息恢复系统,有发送次数,和查询老的有多少消息 一般查前5分钟前的      这种方案增加压力--->注意要有一个消息恢复系统
	比较适用于,A业务做完,B必须做完,,             ,b业务不影响 a业务 的场景     
	缺点 耦合性高,使用的是业务系统的数据库 
	
	方式2: 把消息服务子系统  单独出来,单独两个 消息子系统,,,  使用自定义的 数据库
TCC : 
	需要一个数据库  存储对应的状态,哪个阶段  为了宕机后 起来接着做
	
	Try: 尝试执行业务,完成所有业务检查（一致性）,预留必须业务资源（准隔离性）
	Confirm: 确认执行业务,真正执行业务,不作任何业务检查
		只使用Try阶段预留的业务资源
		Confirm操作满足幂等性
	Cancel: 取消执行业务,释放Try阶段预留的业务资源
	Cancel操作满足幂等性
	
	xml添加上对应的dubbo参数  对应的我们直接 autowrid举行

	try---预留资源::: 先去尝试看看能不能成功,,, 也就是先把资源给修改了  先把资源占用    try是一个同步的调用

	Confirm--  执行真正的的 业务 也就是 调用对应的 服务的congfirm方法   但是一定要实现 幂等性
	
	Cancel  取消操作--也就是把资源释放  如果是成功的 还好, 失败的要进行回补
	
	重::: 一般有对应的注解 声明是对应的方法  比如:Confirm方法,Cancel方法    
	如果在真实项目中使用，需要保证CONFIRM和CANCEL方法的幂等性。

	业务活动管理器             控制业务活动的一致性，它登记业务活动中的操作，
	 并在业务活动提交时确认所有的TCC型操作的confirm操作，
	在业务活动取消时调用所有TCC型操作的cancel操作
	
使用TCC框架 <<< 步骤>>>         需要在对应的try方法上贴上 @Compensable(cnfirmMethod="方法名",cancelMethod="方法名")
		   并引入对应的依赖  TCC的依赖     并在web.xml文件中添加对应的读取tcc-transaction.xml文件 这个文件是在依赖里面
		













