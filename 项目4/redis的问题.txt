redis的穿透:	
	处理方案:
	1,在应用的程序中,需要对传入的参数做 校验	
	2,如果从数据库查出来后 都要存到redis中  如果是null也要存到redis 并设置失效时间 比如5s, 主要是为了如果有大量的这种情况,对正常的操作就 影响比较大了
	3,一般我们会先把key存储到redis的集合,这是合理的key, 如果查询的时候, 先判断 是否有这个key 如果有就合理,再进行redis的get方案,
		如果不存在就应该报异常,
'
redis雪崩:
	在高并发的情况(任何都在访问),redis中大量的key同时失效,此时,大量的请求落在数据库中,导致数据库被拖垮
	
	处理方案:
	1,尽量在设置redis的key失效时间的时候 加入随机数,  让redis的key失效时间 分散开
	2,双缓存,redis1失效,然后去reids2(永不失效),然后给MQ消息去数据库查  然后再更新redis1 , redis2的数据
	3,redis1永不失效,redis2有失效时间,       redis2存储一个redis1的key的前缀 然后通过监听redis2的失效 然后再删除对应key的redis1的数据
分布式锁:
	redis
	zookeeper
	数据库  这三个都可以实现分布式锁
	
	redis    key应该是oLock:orderNo  同一订单 
		避免死锁; 需要设置失效时间  set("Key","val","NX","EX",5) 同时设置时间
	应用场景: 多个集群,操作同一个资源,多个访问,就让一个过去

	zookeeper   也就是 创建临时节点   单线程的   如果有异常 也就会断开,,,也有选举机制
		可以创建有序的节点,按最小的当主,   可以做共享锁:监听master  顺序执行