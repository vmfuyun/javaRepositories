切面优先级:
实现Ordered接口
	private int order =数值越小,优先级越高!                                                  ---用来判断多个切面的 执行顺序
	
pointcut 可以写入@annotation(xxx) 标志着 我要切主要是贴了这个注解的方法
	pointcut 是代表着 这你要切 的那个方法!!!    getArgs 获取对应的参数列表      
	
	它有一个transactionContext的类 看是否这个方法(参数)传入了这个参数    以这个来判断是否是主业务   ---判断方式   关键     技巧
	
	然后在这个方法上进行 开始事务管理 也就是一个全局的事务管理   rootMethodProceed       一般使用的是一个环绕通知 
	会先去插入一个 全局的id表 是一个事务表 然后通过这个事务表来 开启一次真正的会话   也就是说 如果几个服务就是几个表 再加一个  类似于消息表
	它是先去每一个贴了对应的注解的方法上 去获取对应的 方法名并开启事务    会把一个参与者 直接序列化 到sql   
		一般是把confirm方法 和cancel方法 反射出来  然后加到同一个事务上  并存到 sql中
		
类似于同步的时候,把try做一遍  然后把存到sql的上下文 取出来 整个确认提交              通过状态来实现 不一样的操作   
	如果try成功  后面的失败的话  后面就会进行一个定时器操作(120秒)   quartz     因为对应的状态是有的
	
	quartz 定时器:::  使用的是一个cronExpression="0 */1 * * * ?"  的表达式    默认是120秒  重试30
	会在TransactionRecovery的类  执行对应startRecover方法-->loadErrorTransactions方法   
		获取到 数据库中 事务对象创建了 120秒的对象集合     然后进行重试 操作
		如果次数超过规定的数  那么就实行人工操作
		 \
	考虑如果主root 断电的话 需要把事务进行回滚
	完全利用的是 切面加拦截器 反射 实现调用
	
	在监听的时候 把beanFactory得到 也就是把spring的容器获取 ,就可以获取对应的bean
	
	confirm和cancel 必须是幂等性的  因为 有可能会定时器 重复操作
		