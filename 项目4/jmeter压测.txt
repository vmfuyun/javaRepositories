意识:对前端传的数据 都要进行校验
	
	秒杀逻辑
	1登陆
	2,秒杀是否开始
	3,判断是不是已经购买	
	4,判断数据库库存
	5,(原子操作)
		对应的场次的库存-1
		订单 order_inof
		秒杀订单 seckill_order
	跨域的会设置成   xhrxxx 带上cookies
	
	注意修改 列名属性名
	参数解析器 过程: 看图
	在memberapi

在秒好 api   domain
在controller 添加 上判断
在service 原子性操作实现  @注解
对应的创建

查看订单信息
	一般需要只能看自己的订单 



jmeter  压力测试
	线程组     http请求默认表    http请求 添加地址
	监听器 聚合报告
	qps吞吐量-->每秒钟能处理的查询数
	TPS                每秒能处理的事务数
	
	QPS说的是系统 和处理器的查询数
	服务器 多少台
	用户量  活跃用户 
	答题 思路 
	一般 只有运维才能操作  才知道 有多少
	或者用的是Docker   ,
	
	用户量:  100万  一般活跃性 10万-20万    
	281万	QPS一般是9000

	测试秒杀  添加cookies 管理器
	
	超卖分析:
	cpu切换   进行到不同的代码  会出现超卖的情况
	
	优化:
	如果一开始就放到redis中(商品预热) --->解决查看慢 >>
	>正常的  会专门有一个后台,,, 进行放到redis
redis为什么性能高?
	1,基于内存的操作
	2,数据结构简单
	3,单线程
	4,IO多路复用  ---->

超卖    利用的是 redis的原子性 递减 decr  因为 进入到redis中的是单线程的,  然后后面进行 判断的话 肯定是单线程的
	判断的时间是大于CPU的切换的时间
	
	一般使用redis的缓存,会把原始的快一倍    很明显的
标识	
	在当地做一个标识,来判断 减少对redis的访问 因为redis访问也是一个网络访问--消耗比较大 ,注意 有可能是第一次value是个null 
	   hashTable--线程安全	全部hash表加锁   -->效率低
	hashMap   --不安全--是一个hash表 ,  在CPU切换的时候 就有可能把原先的数据进行覆盖
	CurrentHashMap  分段锁.   -->效率是比较高的
	

	
	hashMap扩容机制:  如果达到了map的扩容因子  0.75   就会扩容  是按着 二进制,1111000  --->11110000进行添加一个0 也就是乘以2
	list      扩容机制:  直接先new list 比原先多一倍的    然后再复制过去  所以是1.5倍
	1,点击 