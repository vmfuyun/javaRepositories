问题:下单的 有大量的线程堵住?会把服务器压垮,处理速度 也很慢?   
	使用MQ的流量削峰,按着服务器处理能力,
	
	那处理完毕怎么返回信息到前端?
	 方案1,使用redis 订单成功后   会存到redis中  通过前端不断地给后端发消息 查redis有没有订单
	方案2,WebSocket协议,长连接,多次返回信息
	
预库存回补:
	请求出错后,是不会有mysql订单的 ,因为是原子性 事务 回滚
	只有下单成功,不支付才会有mysql订单
	
1	加一,不合理  如果预库存减的只剩下负数.
2	不能设置成1,因为有可能预库存不是负数,有可能为8个库存,,, 直接设置成1,就不合理了
3	查真实库存,然后同步到预库存  √	条件:真实库存 大于 0
	
WebSocket :
	协议是ws://
	前端是 对应是打开事件
	...
	
	@serverEndpoint("/{uuid}")  获取路径
	@pathParan 获取路径参数
	下面是四个对应前端的四个事件    socket.onopen  xxx     ,,,  一次连接之后就可以一直连接,,,  每一次操作都是用的对应的方法
		注意在,ServerEndpoint 对应的类上 要由对应的currentHashMap
	@onOpen
	@onmessage	
	@onClose
	@onError
	map是uuid : this     每一个调用  this是不一样的 类似和客户端一致
	
	配置类配置:new ServerEndpointExporter() 的bean
	
异步下单
	依赖,配置, mp vo
	mq监听注入注解   
	server  @payload 会进行注入对象类型的  ;; Channel 不要往

	为了达到延时效果 ;
	必须要使用 自定义的 queue     然后再创建绑定    因为@rabbitListener 是监听 肯定是会 监听到 直接消费了
		并把参数 以map 的形式 添加到 queue上去   然后 再添加一个bingding

   重点	为了实现集群 都能接收到消息, 必须要使用的是  广播fanout      匿名队列                   不然 会变成worder模式  关键
		想想一下  集群有几个 代码就有几个 交换机肯定是一个的  如果队列的名字也是死的 那就只能是一个队列了  因为RabbitMQ只有一个,,, 就变成worder模式了
    
	
	消息队列的做法 一般是先写监听  ..... 死信队列要进行 单独配置  注意死信队列的参数
    超时 这边消息队列 存的只是一个 orderNo
	如果是手动取消和付款的情况  就return
	多考虑极端情况:

      建立一个webSocket 项目  是springBoot    所以 不能用springCloud的东西
	1,引入自己的依赖   2,自己的配置
	因为:消息队列 后面的处理 并不一定比webSocket的快     怎么处理呢  ?   直接先睡一秒 然后再去获取 然后没有再等三次 就算了
      

	注意;乐观锁











