大型秒杀中如何减库存？
目前来看，业务系统中最常见的就是预扣库存方案，像你在买机票、买电影
票时，下单后一般都有个“有效付款时间”，超过这个时间订单自动释放，这都
是典型的预扣库存方案。而具体到秒杀这个场景，应该采用哪种方案比较好呢？
由于参加秒杀的商品，一般都是“抢到就是赚到”，所以成功下单后却不付
款的情况比较少，再加上卖家对秒杀商品的库存有严格限制，所以秒杀商品采
用“下单减库存”更加合理。另外，理论上由于“下单减库存”比“预扣库
存”以及涉及第三方支付的“付款减库存”在逻辑上更为简单，所以性能上更占
优势。
“下单减库存”在数据一致性上，主要就是保证大并发请求时库存数据不能
为负数，也就是要保证数据库中的库存字段值不能为负数，一般我们有多种解决
方案：									(重要)
一种是在应用程序中通过事务来判断，即保证减后库存不能为负数，否则
就回滚；
另一种办法是直接设置数据库的字段数据为无符号整数，这样减后库存
字段值小于零时会直接执行?SQL?语句来报错；
再有一种就是使用?CASE?WHEN?
判断语句，例如这样的?SQL?语句：
UPDATE  item   SET    inventory    =    CASE   WHEN   inventory   >=  xxx  
THEN               inventory-xxx         ELSE             inventory      END




热点库:
由于?MySQL?存储数据的特点，同一数据在数据库里肯定是一行存储
（MySQL），因此会有大量线程来竞争?InnoDB?行锁，而并发度越高时等待线
程会越多，TPS（Transaction?Per?Second，即每秒处理的消息数）会下降，响
应时间（RT）会上升，数据库的吞吐量就会严重受影响。
这就可能引发一个问题，就是单个热点商品会影响整个数据库的性能，?导致?
0.01%?的商品影响?99.99%?的商品的售卖，这是我们不愿意看到的情况。一个
解决思路是遵循前面介绍的原则进行隔离，把热点商品放到单独的热点库中。但
是这无疑会带来维护上的麻烦，比如要做热点数据的动态迁移以及单独的数据库
等。
而分离热点商品到单独的数据库还是没有解决并发锁的问题，我们应该怎么
办呢？要解决并发锁的问题，有两种办法：
应用层做排队。按照商品维度设置队列顺序执行，这样能减少同一台
机器对数据库同一行记录进行操作的并发度，同时也能控制单个商品占用
数据库连接的数量，防止热点商品占用太多的数据库连接。
数据库层做排队。应用层只能做到单机的排队，但是应用机器数本身
很多，这种排队方式控制并发的能力仍然有限，所以如果能在数据库层做
全局排队是最理想的。阿里的数据库团队开发了针对这种?MySQL?的?
InnoDB?层上的补丁程序（patch），可以在数据库层上对单行记录做到并
发排队。
你可能有疑问了，排队和锁竞争不都是要等待吗，有啥区别？
如果熟悉?MySQL?的话，你会知道?InnoDB?内部的死锁检测，以及?MySQL?
Server?和?InnoDB?的切换会比较消耗性能，淘宝的?MySQL?核心团队还做了很
多其他方面的优化，如?COMMIT_ON_SUCCESS?和?ROLLBACK_ON_FAIL?的
补丁程序，配合在?SQL?里面加提示（hint），在事务里不需要等待应用层提交
（COMMIT），而在数据执行完最后一条?SQL?后，直接根据?
TARGET_AFFECT_ROW?的结果进行提交或回滚，可以减少网络等待时间（平均
约?0.7ms）。据我所知，目前阿里?MySQL?团队已经将包含这些补丁程序的?
MySQL?开源。
另外，数据更新问题除了前面介绍的热点隔离和排队处理之外，还有些场景
（如对商品的?lastmodifytime?字段的）更新会非常频繁，在某些场景下这些多
条?SQL?是可以合并的，一定时间内只要执行最后一条?SQL?就行了，以便减少对
数据库的更新操作。