  讲的就是  javabean     这个是一个组件   可重用
	属性  :  不是字段,是通过get/set方法来推导的   ;  去掉get 或者 set 剩下的首字母小写 就是属性
					        主要的那几个点  public  有无返回 无参数
		
  Introspector类   有 些 本类没有肯定父类有  native底层是 c或者c++写的
		该类方法 全是静态的方法
  获取属性的类     getbeanInof       inof  一般是全部获取的意思      (Class<?> beanClass)
"字符串".equals(string类型的变量)     判断这个变量和这个是不是相等

注意 得到属性的类型   //.....多想想

步骤 1     获取javabean的描述对象   getBeanInof方法      (Class<?> beanClass)

步骤 2     获取javabean中的属性描述器  通过描述对象的getPropertyDescriptors方法得到是描述器的数组包括属性名称 方法 
                  有数组就迭代 foreach  就得到settre方法和gerter方法 和名称       


通过字节码文件           xxx.class.newInstance 创建字节码源类的对象

   
   newInstance
public T newInstance()
              throws InstantiationException,
                     IllegalAccessException创建此 Class 对象所表示的类的一个新实例。如同用一个带有一个空参数列表的 new 表达式实例化该类。如果该类尚未初始化，则初始化这个类。 
注意，此方法传播 null 构造方法所抛出的任何异常，包括已检查的异常。使用此方法可以有效地绕过编译时的异常检查，而在其他情况下编译器都会执行该检查。 Constructor.newInstance 方法将该构造方法所抛出的任何异常包装在一个（已检查的）InvocationTargetException 中，从而避免了这一问题。 


返回：
此对象所表示的类的一个新分配的实例。 
抛出： 
IllegalAccessException - 如果该类或其 null 构造方法是不可访问的。 
InstantiationException - 如果此 Class 表示一个抽象类、接口、数组类、基本类型或 void； 或者该类没有 null 构造方法； 或者由于其他某种原因导致实例化失败。 
ExceptionInInitializerError - 如果该方法引发的初始化失败。 
SecurityException - 如果存在安全管理器 s，并满足下列任一条件： 
调用 s.checkMemberAccess(this, Member.PUBLIC) 拒绝创建该类的新实例 
调用者的类加载器不同于也不是当前类的类加载器的一个祖先，并且对 s.checkPackageAccess() 的调用拒绝访问该类的包 
