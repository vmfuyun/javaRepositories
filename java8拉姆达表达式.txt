语法: 覆盖方法的参数列表 -> 表达式(方法执行体)
	
	 前面是一个 参数列表  也就是 方法体的 参数           ----->  是方法的 执行体


Lambda 表达式主要应用在一个方法         需要带一个接口类型  (参数)，而且接口只有一个抽象方法时，
在创建匿名内部类时	一些固定的可推导不可变的代码，	使用一种比较简单的语法来表示，
由编译器自由推导出来----->让编译器 自己的判断  一般是可以推导出来的   前面的前提  必须是一个方法什么的 比较重要  

注意String 有一个 可以不区分 大小写 比较的方法

new thread(   new runable() {} ).start();  注意线程

注意排序  comparable.....                                                                           
	Arrays.sort(要排序的数组, 排序规则   这个可以用拉姆达  )


肤浅的 认知  是 参数名 -> 方法体    这也是必须的准则      
当 一个接口 只有一个方法的时候  ,, java8 的新特性 可以直接省去实现它的 步骤  ;;;  直接 操作的是它的只有一个的接口方法  ,

	,  参数就是接口方法的参数  (形参是 不用管是什么名字的 ,,索引可以随便写 )   因为是接口方法 ,, 所以 只要满足接口方法 的返回值就行了  
	就会 变成   当需要这个 对象的时候    就只剩下 接口中的 唯一的方法 参数-> 方法体  
	
	例子: Aggregations aggregations = elasticsearchTemplate.query(builder.build(),
                response -> response.getAggregations());

下面是 官方的说法
	Lambda 函数式编程语法：
	方法的参数列表 -> 方法执行体

	使用Lambda表达式前提记住三个一定:
	1:  表达式一定是某个函数式接口的对象简化                 函数式接口 可以 肤浅的认为       一个接口 只有 一个 要被复写的方法  的  这种 接口 
	2:  一定是覆盖接口中唯一的抽象方法
	3: 表达式一定是方法中固定的形参

	特殊情况:
	1 方法只有一个形参时,可以省略圆括号
	2 方法体只有1行代码时,可以省略花括号和 return 关键字







语法： 被引用者 :: 引用的方法
1.对象的引用 :: 实例方法名     (System.out::println)
2.类名 :: 静态方法名          (Supplier<Double> s = Math :: random;)
3.类名 :: 实例方法名          (Function<String, Integer> f = String::length;)
4.类名 :: new (构造器引用)       (Supplier<Date> sp = Date::new;)
5.类型[] :: new (数组引用)   (Function<Integer,String[]> f2 = String[]::new;)

内置函数接口
消费 接口Consumer      
	也就说  这个接口的方法是   有参数 无返回  的方法  
	
生产  接口 Supplier
	也就是说 这个接口的方法是 无参数 有返回 的方法	
java.util.function包中全都是内置的函数式接口
比较常见的有4类:
	1 消费型函数接口:Consumer<T>
  	  特点:有参数无返回

	2 供给型函数接口:Supplier<T>
	   特点:无参数有返回

	3 函数处理型接口:Function<T,R>
	   特点:传入T类型的对象,返回R类对象

	4 断言型接口:Predicate<T>
	   特点:对T 类型对象进行断言,返回boolean类型结果


