在Arraylist 有可能是 内存是浪费的,, 有可能申请到内存后  但是不用  因为扩容机制问题

在内存中的存储不是连续的  是通过node(节点)的上下指针来实现的    所以是可以用多少就申请多少个内存 用到是才分配空间
	所以它是删除,新增是快的. (是指插入之后的 操作是很简单的)   记住链表的 图形表达是什么样的         注意在代码中 指针肯定是一个 对象, 包含关系   在里面是一个静态的内部类
	
	如果有重复的 一般使用的是abstract class类进行处理  把所有的需要固定的进行 处理
	
力扣	链表题 : 如果是删除一个给定的值,使用链表的话 是无法获取到上一个节点的 怎么办呢? 直接把 下一个节点的数据覆盖掉当前节点	

链表的话都是使用的是 listNode
面试题:
	反转链表:		reverseList
		递归: 画图看下    递归主要看出口   这个出口就是最后的那个跳转

			public ListNode reverseList(ListNode head){
			if(head==null || head.next==null) return head;
				                
			ListNode newHead = reverseList(head.next);                         ---->这个是进行递归 主要是为了占位               递归注意这个方法是干的什么事情
			head.next.next=head;				--->主要找到了最后的节点,后面的代码就会进行执行
			head.next=null;
			return newHead;
		}

		非递归:
			一个一个的来实现,  解决问题的思路是按着自己现在有的  来实验 一个一个来
			一般需要画图  使用一个临时变量来实现

		ListNode newHead= null;
		while(head !=null){
			ListNode tmp= head.next;        --->先把next取出来 交给一个变量 以防后面用的时候  找不到
			head.next=newHead;
			newHead=head;                       --->把当前的head节点赋值给新的节点
			head=tmp;		--->把临时后面挂靠的 重新赋给head	   当进行判断的时候  tmp就是后面的listNode就是head了(重要)
		}		
		
	判断链表是否有环?
		快慢指针操作办法      
			也就是说 如果有环的话,快的指针和慢的只能就会相遇(也就是用一个快指针一个 一下子next两次)(慢的指针进行一次操作) (关键)
			想操场, 一个跑的快的,肯定会和跑的慢的相遇-->也就是快的每次都会多一个距离,慢慢的就会追上跑的慢的人
		快指针先达到null 就是没有环                        这个跨步 尽量进行要多个隔离

	

	时间复杂度:一般是按着size算