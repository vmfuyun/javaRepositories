同步锁池:
	同步锁必须选择多个线程共同的资源对象   (堆中的) 

	多个线程只有使用相同的 一个对象的时候,, 多线程之间才有互斥效果.
	我们把这个用来做互斥的对象称之为,同步监听对象/同步锁.


	同步锁对象可以选择 任意类型的对象即可,只要保证多个线程使用的是相同锁对象即可
	
	因为只有同步锁对象才能调用wait和notify方法,所以 wait和notify方法应该存在于Object类中




线程通讯   wait   和   notify   方法
	java.lang.Object类提供这两个方法
              wait()执行该方法的线程对象 释放同步锁,然后被放在等待池中,等待唤醒
              notify(),唤醒任意一个线程
              notifyAll();唤醒所有
线程操作  :方法  static void sleep( long millis)相当于网络延迟'
	对象 join   对象是谁 先执行谁  知道结束    
	后台    是不是后台线程  使用  Thread.isDaemon();
	            设置成后台线程 必须在调用start之前  (加入线程池之前)    thread.setDaemon(ture)         

Lock机制  Condition接口(接口中有所有的操作唤醒 等待 方法)  

对象       .     join方法等待这个线程执行完毕后再进行  别的线程'

处理并发的问题的类
	在java.util.concurrent.atomic 提供了很多安全的类  都有对应对象的比如:AtomicInteger  xxx
	里面也有很多对应的操作,  比如什么先获取值后递增. (前置++, 后置++)
	底层是CAS原理,
	